"""Tests for quest selection flow.

These tests verify the quest selection phase that occurs after character creation.
The flow is: CHARACTER_CREATION -> QUEST_SELECTION -> EXPLORATION

Tests are written to FAIL until the quest selection flow is implemented in the API.
"""

from __future__ import annotations

from typing import TYPE_CHECKING

import pytest

from src.state.models import GamePhase, GameState, Quest, QuestObjective

if TYPE_CHECKING:
    from fastapi.testclient import TestClient

    from tests.conftest import SessionStateHelper


class TestQuestSelectionModels:
    """Tests for quest selection model additions."""

    def test_quest_selection_phase_exists(self) -> None:
        """GamePhase should have QUEST_SELECTION value.

        The GamePhase enum needs a new QUEST_SELECTION phase to represent
        the state where the player is choosing from available quest options.
        """
        assert hasattr(GamePhase, "QUEST_SELECTION")
        assert GamePhase.QUEST_SELECTION.value == "quest_selection"

    def test_game_state_has_pending_quest_options(self) -> None:
        """GameState should have pending_quest_options field.

        When in QUEST_SELECTION phase, the game state needs to store
        the 3 quest options generated by QuestDesignerAgent.
        """
        state = GameState(session_id="test-123")

        assert hasattr(state, "pending_quest_options")
        assert state.pending_quest_options == []

    def test_pending_quest_options_accepts_quest_list(self) -> None:
        """pending_quest_options should accept a list of Quest objects."""
        quest1 = Quest(
            id="q1",
            title="Quest 1",
            description="Description 1",
            objectives=[QuestObjective(id="obj-1", description="Find the artifact")],
        )
        quest2 = Quest(
            id="q2",
            title="Quest 2",
            description="Description 2",
            objectives=[QuestObjective(id="obj-2", description="Defeat the dragon")],
        )

        state = GameState(
            session_id="test-123",
            pending_quest_options=[quest1, quest2],
        )

        assert len(state.pending_quest_options) == 2
        assert state.pending_quest_options[0].title == "Quest 1"
        assert state.pending_quest_options[1].title == "Quest 2"

    def test_pending_quest_options_serializes_correctly(self) -> None:
        """pending_quest_options should serialize and deserialize with GameState."""
        quest = Quest(
            id="q1",
            title="Test Quest",
            description="Test description",
            objectives=[QuestObjective(id="obj-1", description="Test objective")],
        )

        original_state = GameState(
            session_id="test-456",
            pending_quest_options=[quest],
        )

        # Serialize to JSON and back
        json_str = original_state.model_dump_json()
        restored_state = GameState.model_validate_json(json_str)

        assert len(restored_state.pending_quest_options) == 1
        assert restored_state.pending_quest_options[0].title == "Test Quest"


class TestQuestSelectionFlow:
    """Tests for quest selection API flow.

    These tests verify the expected flow:
    1. After character creation, game transitions to QUEST_SELECTION phase
    2. Player sees 3 quest options to choose from
    3. Selecting a quest activates it and transitions to EXPLORATION
    """

    def test_character_creation_transitions_to_quest_selection(
        self, client: TestClient, session_state: SessionStateHelper
    ) -> None:
        """After character creation completes, phase should be QUEST_SELECTION.

        When the character creation interview is complete and the CharacterSheet
        is finalized, the game should transition to QUEST_SELECTION phase instead
        of going directly to EXPLORATION.

        This test will FAIL until the API is updated to:
        1. Transition to QUEST_SELECTION after character creation
        2. Generate quest options using QuestDesignerAgent.generate_quest_options()
        """
        # Start with skip_creation to quickly get past character creation
        response = client.get("/start?skip_creation=true")
        assert response.status_code == 200
        session_id = response.json()["session_id"]

        # Get the current phase - should be QUEST_SELECTION after character is created
        phase = session_state.get_phase(session_id)

        # Currently this transitions directly to EXPLORATION
        # This assertion will FAIL until the flow is updated
        assert phase == GamePhase.QUEST_SELECTION, (
            f"Expected QUEST_SELECTION phase after character creation, "
            f"got {phase}. The API should transition to QUEST_SELECTION "
            f"after character creation, not directly to EXPLORATION."
        )

    def test_quest_selection_presents_three_options(
        self, client: TestClient, session_state: SessionStateHelper
    ) -> None:
        """In QUEST_SELECTION phase, player should see 3 quest choices.

        When entering QUEST_SELECTION phase, the API should:
        1. Call QuestDesignerAgent.generate_quest_options()
        2. Store the 3 quests in pending_quest_options
        3. Present the quest titles as choices to the player
        """
        # Start with skip_creation
        response = client.get("/start?skip_creation=true")
        assert response.status_code == 200
        session_id = response.json()["session_id"]

        # Get session and check pending_quest_options
        session = session_state.get_session(session_id)
        assert session is not None

        # Currently pending_quest_options is empty
        # This assertion will FAIL until quest options are generated
        assert len(session.pending_quest_options) == 3, (
            f"Expected 3 pending quest options, got {len(session.pending_quest_options)}. "
            f"After character creation, generate_quest_options() should be called "
            f"to populate pending_quest_options with 3 Quest objects."
        )

    def test_selecting_quest_activates_it(
        self, client: TestClient, session_state: SessionStateHelper
    ) -> None:
        """When player selects a quest, it becomes the active_quest.

        In QUEST_SELECTION phase, the player's choice should result in
        that quest being set as active_quest on the GameState.
        """
        # Start with skip_creation
        response = client.get("/start?skip_creation=true")
        assert response.status_code == 200
        session_id = response.json()["session_id"]

        # Get session and verify initial state
        session = session_state.get_session(session_id)
        assert session is not None

        # Currently the API assigns a quest directly in EXPLORATION
        # After the flow change, active_quest should be None until selection
        # This test documents the expected behavior after implementation

        # Check if we're in QUEST_SELECTION (will fail until implemented)
        if session.phase != GamePhase.QUEST_SELECTION:
            pytest.fail(
                f"Expected QUEST_SELECTION phase, got {session.phase}. "
                f"Cannot test quest selection without being in QUEST_SELECTION phase."
            )

        # Select a quest (by number or title)
        response = client.post(
            "/action",
            json={"action": "1", "session_id": session_id},
        )
        assert response.status_code == 200

        # Verify the quest is now active
        session = session_state.get_session(session_id)
        assert session is not None
        assert session.active_quest is not None, (
            "active_quest should be set after selecting a quest"
        )

    def test_selecting_quest_transitions_to_exploration(
        self, client: TestClient, session_state: SessionStateHelper
    ) -> None:
        """After selecting a quest, phase changes to EXPLORATION.

        Once the player has selected their quest from the options,
        the game should transition from QUEST_SELECTION to EXPLORATION.
        """
        # Start with skip_creation
        response = client.get("/start?skip_creation=true")
        assert response.status_code == 200
        session_id = response.json()["session_id"]

        # First verify we're in QUEST_SELECTION (prerequisite)
        phase = session_state.get_phase(session_id)
        if phase != GamePhase.QUEST_SELECTION:
            pytest.fail(
                f"Expected QUEST_SELECTION phase, got {phase}. "
                f"Cannot test quest selection transition without being in QUEST_SELECTION."
            )

        # Select a quest
        response = client.post(
            "/action",
            json={"action": "1", "session_id": session_id},
        )
        assert response.status_code == 200

        # Verify transition to EXPLORATION
        phase = session_state.get_phase(session_id)
        assert phase == GamePhase.EXPLORATION, (
            f"Expected EXPLORATION phase after quest selection, got {phase}"
        )

    def test_selecting_quest_clears_pending_options(
        self, client: TestClient, session_state: SessionStateHelper
    ) -> None:
        """After quest selection, pending_quest_options should be cleared.

        Once a quest is selected and becomes active, the pending options
        should be cleared from the game state to free up memory.
        """
        # Start with skip_creation
        response = client.get("/start?skip_creation=true")
        assert response.status_code == 200
        session_id = response.json()["session_id"]

        # First verify we're in QUEST_SELECTION with pending options
        session = session_state.get_session(session_id)
        assert session is not None

        if session.phase != GamePhase.QUEST_SELECTION:
            pytest.fail(
                f"Expected QUEST_SELECTION phase, got {session.phase}. "
                f"Cannot test pending options clearing without being in QUEST_SELECTION."
            )

        # Select a quest
        response = client.post(
            "/action",
            json={"action": "1", "session_id": session_id},
        )
        assert response.status_code == 200

        # Verify pending_quest_options is cleared
        session = session_state.get_session(session_id)
        assert session is not None
        assert len(session.pending_quest_options) == 0, (
            "pending_quest_options should be empty after quest selection"
        )


class TestQuestCompletionFlow:
    """Tests for quest completion triggering new quest selection."""

    def test_quest_completion_triggers_new_selection(
        self, client: TestClient, session_state: SessionStateHelper
    ) -> None:
        """After quest completion, phase should return to QUEST_SELECTION.

        When the active quest is completed (all objectives done and marked COMPLETED),
        the game should transition back to QUEST_SELECTION phase so the player
        can choose their next adventure.
        """
        # Start session with skip_creation to get a character
        response = client.get("/start?skip_creation=true")
        assert response.status_code == 200
        session_id = response.json()["session_id"]

        # Select a quest to start in EXPLORATION phase
        response = client.post(
            "/action",
            json={"action": "Accept: The Missing Merchant", "session_id": session_id},
        )
        assert response.status_code == 200

        # Verify we're in EXPLORATION phase with active quest
        session = session_state.get_session(session_id)
        assert session is not None
        assert session.phase == GamePhase.EXPLORATION
        assert session.active_quest is not None
        quest_title = session.active_quest.title

        # Simulate quest completion by directly updating the session state
        # Mark all objectives as complete
        for obj in session.active_quest.objectives:
            obj.is_completed = True

        # Call complete_quest through session manager
        sm = client.app.state.session_manager

        async def complete_and_transition() -> None:
            # Complete the quest
            await sm.complete_quest(session_id)
            # Get character sheet for quest generation
            state = await sm.get_session(session_id)
            if state and state.character_sheet:
                # Import quest_designer to generate new options
                from src.agents.quest_designer import QuestDesignerAgent

                quest_designer = QuestDesignerAgent()
                new_options = quest_designer.generate_quest_options(
                    character_sheet=state.character_sheet,
                    game_context="Character just completed a quest.",
                )
                await sm.set_pending_quest_options(session_id, new_options)
                await sm.set_phase(session_id, GamePhase.QUEST_SELECTION)

        import asyncio

        asyncio.get_event_loop().run_until_complete(complete_and_transition())

        # Verify the quest was completed and new selection is available
        session = session_state.get_session(session_id)
        assert session is not None
        assert session.phase == GamePhase.QUEST_SELECTION, (
            f"Expected QUEST_SELECTION phase after quest completion, got {session.phase}"
        )
        assert len(session.pending_quest_options) == 3, (
            "Should have 3 new quest options after completing a quest"
        )
        assert len(session.completed_quests) == 1, (
            "Completed quest should be in completed_quests list"
        )
        assert session.completed_quests[0].title == quest_title

    def test_completed_quest_moved_to_completed_list(
        self, client: TestClient, session_state: SessionStateHelper
    ) -> None:
        """Completed quest should be added to completed_quests list.

        When a quest is completed, it should be moved from active_quest
        to the completed_quests list for record keeping.
        """
        # Start session with skip_creation
        response = client.get("/start?skip_creation=true")
        assert response.status_code == 200
        session_id = response.json()["session_id"]

        # Select a quest
        response = client.post(
            "/action",
            json={"action": "Accept: Goblin Troubles", "session_id": session_id},
        )
        assert response.status_code == 200

        # Get initial state
        session = session_state.get_session(session_id)
        assert session is not None
        assert session.phase == GamePhase.EXPLORATION
        assert session.active_quest is not None

        initial_completed_count = len(session.completed_quests)
        quest_title = session.active_quest.title

        # Complete the quest via session manager
        sm = client.app.state.session_manager

        async def complete_quest_only() -> None:
            await sm.complete_quest(session_id)

        import asyncio

        asyncio.get_event_loop().run_until_complete(complete_quest_only())

        # Verify the quest was moved to completed list
        session = session_state.get_session(session_id)
        assert session is not None
        assert len(session.completed_quests) == initial_completed_count + 1, (
            "Completed quest should be added to completed_quests list"
        )
        assert session.completed_quests[-1].title == quest_title, (
            "The completed quest title should match"
        )
        assert session.active_quest is None, (
            "active_quest should be None after completion"
        )


class TestQuestSelectionByIndex:
    """Tests for selecting quests by index (choice number)."""

    def test_select_quest_by_number(
        self, client: TestClient, session_state: SessionStateHelper
    ) -> None:
        """Player can select quest by typing the number (1, 2, or 3)."""
        # Start with skip_creation
        response = client.get("/start?skip_creation=true")
        assert response.status_code == 200
        session_id = response.json()["session_id"]

        # Verify we're in QUEST_SELECTION (prerequisite)
        phase = session_state.get_phase(session_id)
        if phase != GamePhase.QUEST_SELECTION:
            pytest.fail(
                f"Expected QUEST_SELECTION phase, got {phase}. "
                f"Cannot test numeric selection without being in QUEST_SELECTION."
            )

        # Get the pending quest options
        session = session_state.get_session(session_id)
        assert session is not None
        assert len(session.pending_quest_options) >= 2, (
            "Need at least 2 quest options to test selection"
        )

        second_quest_title = session.pending_quest_options[1].title

        # Select by number "2"
        response = client.post(
            "/action",
            json={"action": "2", "session_id": session_id},
        )
        assert response.status_code == 200

        # Verify the second quest is now active
        session = session_state.get_session(session_id)
        assert session is not None
        assert session.active_quest is not None
        assert session.active_quest.title == second_quest_title, (
            f"Expected '{second_quest_title}' when selecting '2', "
            f"got '{session.active_quest.title}'"
        )

    def test_invalid_selection_stays_in_quest_selection(
        self, client: TestClient, session_state: SessionStateHelper
    ) -> None:
        """Invalid quest selection should keep player in QUEST_SELECTION."""
        # Start with skip_creation
        response = client.get("/start?skip_creation=true")
        assert response.status_code == 200
        session_id = response.json()["session_id"]

        # Verify we're in QUEST_SELECTION (prerequisite)
        phase = session_state.get_phase(session_id)
        if phase != GamePhase.QUEST_SELECTION:
            pytest.fail(
                f"Expected QUEST_SELECTION phase, got {phase}. "
                f"Cannot test invalid selection without being in QUEST_SELECTION."
            )

        # Try invalid selection (only 3 options available)
        response = client.post(
            "/action",
            json={"action": "5", "session_id": session_id},
        )
        assert response.status_code == 200

        # Should stay in QUEST_SELECTION phase
        phase = session_state.get_phase(session_id)
        assert phase == GamePhase.QUEST_SELECTION, (
            f"Should remain in QUEST_SELECTION after invalid selection, got {phase}"
        )

        # active_quest should still be None
        session = session_state.get_session(session_id)
        assert session is not None
        assert session.active_quest is None, (
            "active_quest should remain None after invalid selection"
        )
